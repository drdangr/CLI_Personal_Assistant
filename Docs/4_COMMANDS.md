### Общее устройство

Файл `commands.py` реализует весь «каталог» команд консольного помощника: хранит реестр, декларативно регистрирует обработчики и содержит бизнес-логику для контактов, заметок и системных команд. Базовая идея — каждая команда представлена функцией, которая принимает список строковых аргументов и объект `Storage`, а результатом возвращает человекочитаемый ответ. Набор вспомогательных декораторов избавляет от рутинного кода: автоматическая регистрация, обработка ошибок и автосохранение.

### Реестр команд

- Класс `CommandRegistry` держит три структуры: `handlers`, `help` и `min_args`, где ключ — нормализованное имя команды. Метод `register()` возвращает декоратор, который закрепляет функцию, её описание и минимальное количество аргументов, запрещая дубли (*RuntimeError* при повторной регистрации). Метод `validate_args()` проверяет количество аргументов до вызова handler. Благодаря методу `resolve()` CLI может проверить, существует ли команда, а `help_text()` формирует общий список для `help`.  
```18:97:commands.py
class CommandRegistry:
    ...
```

- Глобальный экземпляр `REG` используется всем модулем. Это единственная точка регистрации, поэтому список доступных команд централизован.  
```107:107:commands.py
REG = CommandRegistry()
```

### CommandRegistry: назначение и устройство. Подробный разбор.

`CommandRegistry` — небольшой сервис-класс, который хранит все команды CLI, их краткие описания и принадлежность к разделам. Он обеспечивает регистрацию, поиск и выдачу подсказок, а также помогает другим частям программы узнать, какие команды доступны.

```18:25:commands.py
class CommandRegistry:
    """Реєстр команд зі суворим зіставленням за іменем."""

    def __init__(self) -> None:
        self._handlers: Dict[str, Handler] = {}
        self._help: Dict[str, str] = {}
        self._sections: Dict[str, str] = {}
        self._min_args: Dict[str, int] = {}
```

- При создании (`__init__`) класс заводит четыре словаря:
  - `_handlers`: имя команды → функция-обработчик (`Handler`).
  - `_help`: имя команды → строка справки (короткое описание для `help`).
  - `_sections`: имя команды → название раздела, в котором команда отображается при вызове `help`.
  - `_min_args`: имя команды → минимальное количество обязательных аргументов.

#### register()

```27:45:commands.py
    def register(
        self, name: str, *, help: str = "", section: str | None = None, min_args: int = 0
    ) -> Callable[[Handler], Handler]:
        """Зареєструвати команду."""

        def decorator(func: Handler) -> Handler:
            key = name.strip().lower()
            if key in self._handlers:
                raise RuntimeError(f"Duplicate command: {name}")
            self._handlers[key] = func
            self._help[key] = help.strip()
            self._min_args[key] = min_args
            normalized_section = section.strip() if section else DEFAULT_SECTION
            if normalized_section not in SECTION_ORDER[:-1]:
                normalized_section = DEFAULT_SECTION
            self._sections[key] = normalized_section
            return func

        return decorator
```

- Метод возвращает декоратор, которым оборачивают функции-обработчики.
- Приводит имя к нижнему регистру и обрезает пробелы — регистрация/поиск регистронезависимые.
- Запрещает дубли имен: при повторном `register("add")` сразу выбрасывает `RuntimeError`.
- Сохраняет обработчик, описание, раздел и минимальное количество аргументов в словари, затем возвращает саму функцию (чтобы декоратор не менял поведение).
- Параметр `section` необязателен; если он не указан или не попадает в допустимый список (`SECTION_ORDER`), команда окажется в разделе «Прочее».
- Параметр `min_args` (по умолчанию 0) определяет минимальное количество аргументов, которые требуются команде. Валидация происходит автоматически в `cli.py` перед вызовом handler.

#### resolve()

```38:42:commands.py
    def resolve(self, name: str) -> Optional[str]:
        """Вернуть точное имя команды, если оно зарегистрировано."""
        k = name.strip().lower()
        return k if k in self._handlers else None
```

- Нормализует имя и проверяет, есть ли такая команда.
- Нужен, например, для `help foo`: CLI может сначала узнать, зарегистрирована ли команда, прежде чем пытаться вызвать обработчик.
- Возвращает нормализованное имя или `None`.

#### validate_args()

```56:66:commands.py
    def validate_args(self, cmd_name: str, args: List[str]) -> None:
        """Перевірити кількість аргументів для команди."""
        key = cmd_name.strip().lower()
        min_required = self._min_args.get(key, 0)
        
        if len(args) < min_required:
            help_text = self._help.get(key, "")
            if help_text:
                raise IndexError(f"Not enough arguments. {help_text}")
            else:
                raise IndexError(f"Command '{cmd_name}' requires at least {min_required} argument(s)")
```

- Проверяет, достаточно ли аргументов передано для команды.
- Если аргументов меньше, чем `min_args`, выбрасывает `IndexError` с текстом справки.
- Вызывается в `cli.py` автоматически перед вызовом handler.

#### handler()

```52:54:commands.py
    def handler(self, key: str) -> Handler:
        """Отримати обробник за ключем."""
        return self._handlers[key]
```

- Возвращает саму функцию-обработчик.
- Предполагается, что `key` валиден (обычно перед получением вызывается `resolve`); в противном случае будет `KeyError`.

#### all_commands()

```68:70:commands.py
    def all_commands(self) -> List[str]:
        """Отримати список всіх команд."""
        return sorted(self._handlers.keys())
```

- Возвращает отсортированный список всех зарегистрированных имён.
- Используется для вывода справки и автодополнения (если нужно).

#### get_help()

```72:75:commands.py
    def get_help(self, name: str) -> str:
        """Отримати довідку команди за її іменем."""
        key = name.strip().lower()
        return self._help.get(key, "")
```

- Возвращает описание, которое было передано при регистрации, или пустую строку, если команда не найдена/описание не задано.

#### help_text()

```77:97:commands.py
    def help_text(self) -> str:
        """Повернути компактний текст довідки."""
        groups: Dict[str, List[str]] = {section: [] for section in SECTION_ORDER}
        for cmd in self.all_commands():
            section = self._sections.get(cmd, DEFAULT_SECTION)
            groups.setdefault(section, []).append(cmd)

        lines = ["Доступные команды:"]
        for section in SECTION_ORDER:
            cmds = groups.get(section, [])
            if not cmds:
                continue
            lines.append("")
            lines.append(f"{section}:")
            for cmd in cmds:
                desc = self._help.get(cmd, "")
                lines.append(f"  - {cmd}: {desc}")

        lines.append("")
        lines.append("Для деталей по конкретной команде используйте: help <command>")
        return "\n".join(lines)
```

- Формирует многострочный текст, где команды выводятся блоками: «Телефонная книга», «Заметки», «Система» и «Прочее».
- Секции идут в фиксированном порядке (`SECTION_ORDER`), но пустые блоки пропускаются.
- Внутри блока перечисляются сами команды с описанием; финальная подсказка напоминает про `help <command>`.
- В модуле объявлены константы `SECTION_PHONEBOOK`, `SECTION_NOTES`, `SECTION_SYSTEM`, `SECTION_ORDER` и `DEFAULT_SECTION`. Они задают человекочитаемые названия разделов и гарантируют, что команды без секции окажутся в последнем блоке — «Прочее».

### Жизненный цикл

1. Где-то в `commands.py` объявляют глобальный `REG = CommandRegistry()`.
2. Каждая команда оформлена функцией с декораторами `@REG.register("имя", help="...", section="...", min_args=N)`, опционально `@input_error`, `@mutating`.
3. CLI-парсер получает строку от пользователя, определяет имя команды, нормализует его и вызывает:
   - `REG.resolve(name)` → проверка существования команды.
   - `REG.validate_args(name, args)` → автоматическая проверка количества аргументов.
   - `REG.handler(key)` → получение самой функции.
4. После выполнения обработчика CLI показывает строку-результат пользователю.
5. Команда `help` использует `REG.help_text()` или `REG.get_help()` для подробностей.

Благодаря этому класс служит «центральной адресной книгой» всех команд: регистрация автоматизирует добавление, предотвращает дубли, валидирует количество аргументов, а извлечение/справка происходят через единый API.

### Общие декораторы

- `input_error` — ловит типичные исключения и преобразует их в дружелюбные сообщения.  
  * `KeyError` → «Not found: ...» (нет контакта/заметки),  
  * `ValueError` → «Value error: ...»,  
  * `IndexError` → текст usage (выбрасывается `validate_args()`) или «Not enough arguments»,  
  * прочие → «Error: ...».  
  Благодаря этому бизнес-логика может смело бросать исключения, не заботясь о форматировании ответа.  
```110:138:commands.py
def input_error(func):
    ...
```

- `mutating` — оборачивает команды, которые меняют состояние. После успешного выполнения вызывает `save_storage(storage)`; если ответ начинается с `Error`, либо равен `__EXIT__`, сохранение пропускается, предотвращая ложные записи.  
```141:171:commands.py
def mutating(func):
    ...
```

**Важно:** Функция `require_args()` была удалена в пользу централизованной валидации через `REG.validate_args()`. Теперь проверка количества аргументов происходит автоматически в `cli.py` на основе параметра `min_args` при регистрации команды.

### Команды для контактов

- `cmd_add` добавляет контакт или телефон. Зарегистрирована с `min_args=1` (требует хотя бы имя). Проверяет, существует ли запись; если нет — создаёт `Record(Name(...))`, добавляет первый телефон (если передан) и сохраняет. Если контакт уже есть, но телефон не указан, сообщает о необходимости номера, а при повторяющемся телефоне не дублирует его.  
```193:223:commands.py
@REG.register("add", help='Usage: add "Name" [0123456789]', section=SECTION_PHONEBOOK, min_args=1)
...
```
- Все обработчики в этом разделе регистрируются с `section=SECTION_PHONEBOOK` и соответствующим `min_args`, поэтому в справке итоговый список попадает в блок «Телефонная книга», а валидация аргументов происходит автоматически.

- `cmd_change`, `cmd_phone`, `cmd_all`, `cmd_add_birthday`, `cmd_show_birthday`, `cmd_birthdays` реализуют, соответственно, смену номера, просмотр телефонов, выгрузку всех контактов, работу с днями рождения и список грядущих праздников (по умолчанию 7 дней вперёд, с группировкой по смещениям Today/Tomorrow/…).

- Блок e-mail/адресов:  
  * `cmd_add_email` и `cmd_remove_email` управляют списком e-mail’ов записи; последний возвращает «Email not found», если удалить нечего.  
  * `cmd_set_address` сохраняет адрес.  
  * `cmd_find` выполняет поисковый запрос по всем полям, используя `contacts.search`.  
  * `cmd_delete_contact` удаляет запись, если метод `remove_record` вернул `True`.

### Команды для заметок

- `cmd_add_note` создаёт заметку с обязательным текстом (пустой запрещён). Зарегистрирована с `min_args=2` (название и текст).
- `cmd_list_notes` выводит все заметки с сортировкой по `title` (дефолт) или `created`, форматируя дату и список тегов (если тегов нет — `(no tags)`). Не требует аргументов (`min_args=0`).
- `cmd_find_note` и `cmd_find_tag` ищут по тексту и тегу (`min_args=1`), возвращая перечень подходящих заметок или «No results.».

- `cmd_edit_note` заменяет текст заметки (`min_args=2`); пустой текст блокируется `ValueError`.  
- `cmd_tag_add`, `cmd_tag_remove`, `cmd_delete_note` позволяют управлять тегами и удалять заметку, сообщая об успехе или отсутствии нужного тега/заметки (соответственно `min_args=2`, `min_args=2`, `min_args=1`).

```422:559:commands.py
@REG.register("add-note", help='Usage: add-note "Title" text...', section=SECTION_NOTES, min_args=2)
...
```
- Команды по заметкам получают `section=SECTION_NOTES` и соответствующий `min_args`, и `help` выводит их под заголовком «Заметки».

### Системные команды

- `cmd_hello` возвращает приветствие.  
- `cmd_help` без аргументов выдаёт общий список через `REG.help_text()`, а с именем команды — описание конкретного обработчика или «Unknown command».  
- `cmd_exit` регистрируется как `close` и `exit`, возвращает специальный маркер `__EXIT__`, который CLI воспринимает как сигнал завершения без сохранения.  
- `cmd_version` подгружает константы `APP_NAME`, `APP_VERSION` и путь `STORAGE_FILE`, формируя строку вида `personal_assistant_cli v1.0.0 | data: ...`.  

```412:444:commands.py
@REG.register("hello", ...)
...
```
- Системные команды используют `section=SECTION_SYSTEM`. Если какая-то новая команда не укажет раздел или задаст незнакомое значение, реестр отправит её в «Прочее» (это `DEFAULT_SECTION`).

### Итоговая схема работы

1. CLI парсит ввод в команду и аргументы.
2. CLI вызывает `REG.validate_args()` для проверки количества аргументов (на основе `min_args` при регистрации).
3. CLI получает обработчик через `REG.handler()`.
4. Обработчик почти всегда обёрнут в `@input_error`, а все модифицирующие — ещё и в `@mutating`.  
5. Логика обращается к объекту `Storage`, манипулируя моделями (`Record`, `Note` и т.д.).  
6. Результирующая строка возвращается в интерфейс; при успешных изменениях состояние автоматически сериализуется.

Такое устройство делает файл `commands.py` центром бизнес-логики: добавление новой команды сводится к написанию функции и украшению её нужными декораторами (включая `min_args` для автоматической валидации), после чего команда автоматически появляется в `help` и работает с общей системой обработки ошибок и сохранения данных.